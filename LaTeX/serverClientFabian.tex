% !TEX root =  master.tex 
\chapter{Server-Client Architektur -- Fabian Pulch}

\section{Grundlegende Überlegungen}
Der Aufbau des Planspiels soll zuvor bereits beschrieben multiplayerfähig sein und von mehreren Spielern, jeder jeweils ausgestattet mit einem eigenen Client, spielbar sein. Da man sich gegen ein \glqq Hot Seat\grqq \  Verfahren entschieden hat, wurden Überlegungen hinsichtlich einer Server-Client Architektur getroffen, welche im folgenden erläutert werden. Kernproblemstellung dieses Kapitel ist die Frage, wie die Kommunikation zwischen Server und Client aussehen soll.

\section{Erster Ansatzpunkt}
Zunächst einmal wurde überprüft, ob die Programmiersprache Java, welche zur Implementierung des Projektes ausgewählt wurde, über eigene bereits integrierte Bibliotheken zur Kommunikation via TCP/IP verfügt. Im OSI Referenzmodell ist die Kommunikationslogik des Planspiels in der Anwendungsschicht anzusiedeln und den Transport, Internet und Netzzugriffsschichten dadurch übergeordnet.
%Abbildung zum TCP/IP Modell / OSI Modell einfügen
Java bietet in dem Paket \glqq java.net\grqq \ eine grundlegende Bibliothek an, um über mithilfe sogenannter Sockets über Protokolle wie TCP/IP kommunizieren zu können. Eine Nutzung dieser bereitgestellten Klassen und Interfaces hat den grundlegenden Vorteile, dass auf die Einbettung anderer Drittanbieter Codebibliotheken zur Kommunikationszwecken zwischen Server und Client meist gänzlich verzichtet werden kann. Dadurch bleiben die Systemvoraussetzungen minimal auf eine funktionsfähige Javalaufzeitumgebung beschränkt.  Ein Abhängigkeitsmanagement ist dadurch nicht unbedingt erforderlich.

Java als funktionsfähige Laufzeitumgebung auf Server als auch auf dem Client ist eine Möglichkeit mit Java Bordmitteln das Spiel zu realisieren. Dabei müsste der User allerdings in diesem Fall den Client zur Verfügung gestellt bekommen. Eine zuverlässige Verteilungsmethode des Client müsste also gewährleistet werden. Dies kann beispielsweise mithilfe eines Downloads oder der Übergabe auf einem USB-Stick oder einer CD geschehen. Diese Bereitstellung des Clients ist jedoch nicht sonderlich zeitsparend und benutzerfreundlich, da gegebenenfalls Java, falls noch nicht auf dem für den Client ausgewählten Endgerät installiert, nachgeladen werden muss. Durch diese Problematik mit dem Server und Client als eigenständige Java-Anwendung, wurde die Betrachtung weiterer Alternativen angestrebt.

\section{Zweiter Ansatzpunkt}
Da der erste Ansatz, die Problematik nicht vollständig zufriedenstellend löst, wurde nach einer weiteren Möglichkeit zur Realisierung der Kommunikation gesucht, welche einerseits eine zuverlässige Kommunikation zwischen Client und Server ermöglicht und andererseits für den Endbenutzer einfach zu bedienen ist. Im Laufe der Konzeption ist man auf das Konzept der Websockets in HTML5 gestoßen. Websockets benutzen das sog. Websocketprotokoll \autocite[vgl.][]{WebSocketProtokoll}. Mithilfe dieses Protokoll kann bidirektional zwischen einem Client (in diesem Fall eine Webanwendung) und einem Server (beispielsweise einem Webserver). Das Websocketprotokoll ist in der Anwendungsschicht im TCP/IP Protokollstack anzusiedeln. Die Spielschnittstellenkommunikation, welche regelt welche Daten der Client empfangen soll, in welchem Format etc. und welche Anfragen der Client an den Server schicken kann (beispielsweise \glqq starteRunde\grqq) setzt die Kommunikation in diesem Fall über das Websocketprotokoll voraus. Der vorher beschriebene erste Ansatz setzt lediglich eine etablierte TCP-Verbindung voraus.
Der wesentliche Vorteil der Nutzung von Websockets zur Kommunikation ist die Möglichkeit eine Webanwendung zu bauen. Im Gegensatz zu dem vorherigen Versuch ist dadurch kein Client, welcher in Java geschrieben wird, notwendig. Bei dieser Implementierungsmöglichkeit wird ein Client in Javascript ermöglicht. Dieser Client bietet den grundlegenden Vorteil, welcher mit dem Einsatz einer Webanwendung einhergeht, dass er beim jedem Aufruf der Webanwendung im Hintergrund auf das Endgerät geladen wird. Die Verteilung der benötigten Clientressourcen ist demnach unkomplizierter, als die Ausgabe eines reinen nativen Javaclienten.

Aufgrund dieser Überlegungen wurde der Entschluss getroffen eine Webanwendung zu entwerfen, anstatt eine native Java Server-Client Anwendung zu entwickeln.

Mit dieser Entscheidung wurde allerdings die Frage aufgeworfen, welche Implementierungsmöglichkeiten vorhanden sind. Nach einiger Recherche wurde eine erste Möglichkeit gefunden. Im folgenden werden die Überlegungen im Zusammenhang mit der Einordnung und Bewertung dieses Lösungsversuch erläutert.
\subsection{Server-Client Kommunikation mit dem Framework Spring und Websockets}
Um das Projekt zu verwalten und standardisieren, wird das Build-Management-Tool Maven\autocite[vgl.][]{Maven2} von der Apache Software Foundation genutzt. Dieses ermöglicht ein einfaches Management von Abhängigkeiten zwischen dem Projekt und diversen Softwarebibliotheken. Spring \autocite[vgl.][]{Spring}, eine Sammlung von Bibliotheken, welche die Entwicklung einer Webanwendung wesentlich erleichtern, wird durch Maven hinzugefügt. Durch die Einbindung von Spring ist ein Zugriff auf Bibliotheken möglich, die eine Kommunikation über das sogenannte STOMP Protokoll erlauben.\autocite[vgl.][]{SpringWithSTOMPExample} Dieses Protokoll basiert auf TCP und besitzt Ähnlichkeiten zu HTTP. Einige Befehle sind beispielsweise CONNECT, SEND, SUBSCRIBE, ACK oder DISCONNECT.
Diese Architektur ist vorteilhaft, da die Clientimplementierung nun beliebig durch HTML, CSS und Javascript vorgenommen werden kann. Hierbei wurde der Einsatz von der Bibliothek SockJS auf Clientseite in Erwägung gezogen. Dadurch können alternative Verbindungsmethoden, falls ein Verbindungsaufbau durch Websockets nicht möglich ist, leicht zu implementieren.
Der Hauptvorteil dieser Architektur ist zugleich ein leichter Nachteil. Aufgrund der Tatsache, dass die Codesprachen vom Client und Server minimal unterschiedlich sind, ist mit einem leicht erhöhten Mehraufwand bei der Implementierung zu rechnen.

\subsection{Server-Client Kommunikation mit den Framework Spring als Restwebservice}
Neben der Implementierung eines auf STOMP basierenden Messaging, ist eine Kommunikation zwischen Frontend und Backend über eine sog. REST-Schnittstelle in Erwägung zu ziehen. Dies würde SockJS auf Clientseite nicht mehr zwingend notwendig machen und ist ebenfalls mithilfe von dem Spring-Framework realisierbar. Der zuvor beschriebene Nachteil bleibt dadurch allerdings nicht aus. 

\subsection{Server-Client Kommunikation mit den Frameworks Spring und Vaadin}
Als Alternative zur außschließlichen Kommunikation via Spring ist eine Kombination von dem Framework Vaadin und Spring in den Fokus der Evaluierung gerückt. Vaadin ist ein Framework, welches es ermöglicht den Quellcode des Client in Java zu schreiben. Damit wird der Nachteil des vorherigen Versuchs zwar ausgeglichen, jedoch gestaltet sich die vollständige dynamische Websitengestaltung und die Einbindung von CSS dadurch nicht ganz so intuitiv, wie im Regelfall, der ersten Variante (Client in Javascript).

Diese Implementierungsmöglichkeit einige Vorteile. Beispielsweise vereint die Kommunikation über dieses Framework einige Vorteile von Thin- und Thickclient Architekturen. Ein Thinclient lagert die Benutzeroberflächenlogik auf die Serverseite aus. Dadurch wird der Clientquellcode relativ \glqq klein\grqq \ gehalten. Der Client muss hierbei häufig den Server kontaktieren, was bei langen Round Trip Time der Pakete zu längeren Ladezeiten führt. Ein Thickclient hingegen beinhaltet die Oberflächenlogik. Dadurch wird die Kommunikation zwischen Server und Client auf ein Minimum in laufenden Betrieb reduziert. Allerdings ist die initiale Ladezeit des Thickclient gegenüber dem Thinclient um ein Vielfaches größer, weil mehr Daten anfänglich übertragen werden müssen. Einerseits ist durch den Einsatz von Vaadin die UI Logik auf Serverseite in Java implementiert, sodass der Zugriff auf die Backendlogik einfacher möglich ist und andererseits muss die Website nicht jedes Mal neu geladen werden, wenn der Nutzer Aktionen ausführt. Durch Vaadin wird beim erstmaligen Aufruf eine Javascriptdatei geladen, welche die Kommunikation regelt und mit dem Server nur die jeweiligen Änderungen von Server oder Nutzerseite austauscht. Die Komponenten werden also nach erstmaligem Aufruf nicht erneut geladen, lediglich ihr Inhalt wird ausgetauscht.

Neben diesem Vorteil ist werden durch die Nutzung eines solchen Frameworks automatisch Sicherheitsmechanismen implementiert. Cross Site Request Forgery oder Cross Site Scripting sind Beispiele für Gefahren, welchen man durch einfache effektive Sicherheitsmechanismen, wie die Maskierung von quellcoderelevanten Zeichen entgegnet.

Alternativ zu Vaadin wurde auch das Framework CUBA Platform \autocite[vgl.][]{CUBAPlatform} in Erwägung gezogen. Hierbei ist der Ansatz ähnlich wie bei Vaadin. Es wird ermöglicht das Frontend näher an das Backend zu rücken. Dadurch ist eine schnellere Entwicklung möglich, da die Chance geringer ist, das Probleme beim Austausch von Nutzdaten auftreten. 

\section{Entscheidung und Implementierungsversuch}
Nachdem die verschieden Wege skizziert wurden, musste die Entscheidung getroffen werden, welchen Implementierungsweg man letztlich beschreitet. Zunächst hat man sich für eine Server-Client Kommunikation mit Spring und Vaadin entschieden. Während man diesen Versuch vorangetrieben hat, hat man parallel am einem HTML-Mockup gearbeitet, um dennoch unabhängig von einem konkreten Umsetzungsweg zu bleiben. Nach der Fertigstellung, des HMTL-Mockups wurde versucht, diesen als Template für die weitere Entwicklung der Benutzeroberfläche zu nutzen. Vaadin unterstützt die Implementierung von sogenannten Custom Layouts. Das HTML-Mockup wurde nun also adaptiert und versucht an die Besonderheiten von Vaadin angepasst zu werden. Diese Anpassung gestaltete sich jedoch schwerer als erwartet. Unter anderem variierte das Einfügen von CSS-Dateien. Ebenfalls werden Platzhalter <div> Elemente mit data-bindings verwendet und in Java referenziert (<div data-bind="Label1">), um Eingabeelemente dynamisch einzufügen. Einige Elemente wurden beispielsweise nicht auf Anhieb korrekt angezeigt und eingebunden. Nach einer gemeinsamen Aufwandsschätzung wurde daher die Entscheidung getroffen, diesen Ansatz zu verwerfen. Die auftretenden Probleme wurden zwar stets gelöst, erforderten jedoch fast immer mehr Zeit als erwartet.

Durch die iterative Projektumsetzung, war die Tragweite dieses Beschlusses nicht allzu gravierend. Jedoch brachte diese Entscheidung dennoch Rückschritte im Zeitplan mit sich. 

Anstatt nun die Server-Client Kommunikation via Spring und Vaadin zu Modellierung, wurde der Ansatz über eine sog. Restschnittstelle vorangetrieben. Das Framework Spring wurde im Backend beibehalten. Für die Frontend wurde das HTML-Mockup erneut als Basis verwendet. Mithilfe von Javascript sollen nun GET bzw. POST Anfragen an, den durch Spring bereitgestellten, Webserver mit den konfigurierten Schnittstellen gesendet werden. Um die Programmierung dieser Requests sowie die Selektierung von HTML-Elementen zu erleichtern, wurde die Bibilothek JQuery hinzugefügt. Daneben wurde eine weitere Codesammlung namens Knockout.js eingebunden, um die Daten dynamisch im HTML Dokument einzubinden und Funktionen hinter Buttons zu hinterlegen. Die Implementierung dieses Ansatz verläuft reibungsloser als beim vorherigen Versuch. Die grundlegende Schwierigkeit hierbei liegt nicht beim Austausch von Daten, sondern bei der Umsetzung der Spielmechanik z.B. das Starten einer Runde unter der Bedingung, dass alle Spieler bereit sind. Der Server besitzt des Weiteren keine Möglichkeit den Client aktiv anzusprechen. Lediglich der Client kann den Server anfragen, woraufhin dieser eine passende Antwort schickt. Das ist einer der Nachteile, der Implementierung einer Restschnittstelle einhergehen. Die Verwendung von Websockets würde diesen Nachteil nicht beinhalten, ist aber aufgrund von einer fortgeschritten  begrenzten Zeit nicht praktikabel. 

Durch das Festhalten am der Implementierung eines Restful Webservices, ist man nach einigen Versuchen die Spielmechanik umzusetzen, dem Ziel eines funktionsfähigen Planspiels näher gerückt. Der Datenaustausch findet mithilfe der sog. Javascript Object Notation (JASON) statt. Der Zugriff auf die Attribute der übergebenen Objekte erfolgt über eine Punktnotation (Bsp.: object.attribute). 

Zusammenfassend wurden einige Varianten gegeneinander abgewägt. Zwei dieser Möglichkeiten wurden weiter verfolgt, wobei sich letztlich die Implementierung einer Restschnittstelle durchgesetzt hat innerhalb der begrenzten Zeit.